{"qid": "301253397", "question": ["现在的前端框架全是通过API获得数据，如何记录用户登录状态？"], "question_desc": ["Angular，VUE，React等前端框架全是通过接口获得数据，我怎么记录用户登录状态？ 一般网站都是记录session来记录登录状态，现在的单页应…"], "author": "Meck", "vote": 316, "answer": "很多答案都提到了 JWT、Session、Cookie，但是我发现常常有人混淆这三个概念。或者说不同的语境下大家对 Session 会有不同的理解。首先这三个名词表示的是三个纬度的东西，不能简单地说这个方案可以替代那个方案，更不能直接拿来做比较Session 表示客户端和服务端之间的会话，因为 HTTP 请求是无状态的，所以为了把一个 HTTP 请求跟其他 HTTP 请求关联起来让服务端知道当前在跟它对话的客户端是谁，我们就需要有一种机制来保存这些请求之间的用户数据，这就是会话。所以题主所问的“如何记录用户登录状态”其实就是“如何保持一个会话“。Session 机制的实现一般有两种，最常见的就是服务端给客户端发一个 id，然后在服务端存上这个  id 所对应的数据，如果用户有登录，就把用户的 id 存到对应的数据里。另外一种就是把会话的数据加密签名后发给客户端，这样服务端就不需要再去存数据，典型的例子就是 Rails 的默认 Session 实现。这里的 id 和加密数据的传输和存储一般情况下会用 Cookie 来实现。另外，有人说 “session” 这个词的时候，也可能指他所用的  web 框架对 Session 机制的实现，或者指跟 Session 所关联的数据。但是在这里，我们所说的 Session 都是指 Session 机制。Cookie 是什么就不说了。JWT 是一种 token 的生成标准，具体这个标准是什么样，用 JWT 的好处，这里不展开，可以看官网文档。通常情况下，我们用 JWT 就是为了实现上面讲的第二种 Session 机制，把会话数据（通常就是  user id）存在客户端。搞清楚了这三者的概念，我们再来看下怎么样才是使用 JWT 的正确姿势。有人推荐把 JWT 存在 Local Storage/Session Storage 里，其实这是有风险的，当你的应用有 XSS 漏洞时，攻击者很容易就能拿到用户的 token，然后为所欲为。所以，不推荐把 JWT 存在 Local Storage 等任何可以被 JS 直接读取到的地方。推荐把 JWT 放在 Cookie 里，并且设置 httpOnly 属性。不过，放在 Cookie 里会面临另外一个 CSRF 攻击的风险，你可以通过设置一个 csrf token 来防止此类攻击，现代 web 框架都会自带这个功能，比如：Securing Rails Applications安全 - 为企业级框架和应用而生要注意的是， Cookie 的值会有 4KB 大小的限制，所以不要在 JWT 里塞太多东西。最后总结成一句话回答题主的问题：我们可以通过把 JWT 保存在 Cookie 里来保持 Session。所以你看，如何保持 Session 其实跟你的应用有没有用前端框架，是不是 SPA，关系不大。注：以上方案只针对 web 应用。"}
{"qid": "301253397", "question": ["现在的前端框架全是通过API获得数据，如何记录用户登录状态？"], "question_desc": ["Angular，VUE，React等前端框架全是通过接口获得数据，我怎么记录用户登录状态？ 一般网站都是记录session来记录登录状态，现在的单页应…"], "author": "陈龙", "vote": 619, "answer": "有任何问题都可以在评论区里提出来，我会解答。如果有必要我就写一篇文章，更详细的解释jwt。----------------------------------------问题描述说一般网站都是记录session.....，但是现在更趋向于stateless。服务器端不维护回话状态(session或成为state)，更有利于服务的横向扩展。所以现在JWT(JSON Web Token)的认证方式更为流行，已经是业界标准了。JWT.IO用户提交账号密码，服务器端进行验证。验证通过以后，服务器端会用自己的密钥把用户信息加密成Token返回给前端。前端拿到Token之后保存(一般放在Local Storage里)，每次向服务器端发送请求都会在Request的Header里面带上Authorization: bearer token...服务器端用自己的密钥解析token，如果能解析就是自己认证的用户。如果想了解JWT和Session/Cookies的对比，可以看一下这篇文章：JSON Web Tokens vs. Session Cookies: In Practice回复评论区关于限制用户只能登录一次的问题，可以看这个Stackoverflow得答案：JWT and one(!) session per user / no concurrent sessions在JWT的内容中有一个属性是ist:{\n  &#34;sub&#34;: &#34;1234567890&#34;,\n  &#34;name&#34;: &#34;John Doe&#34;,\n  &#34;iat&#34;: 1516239022\n}iat是Issued At的意思，就是分发这个Token的时间。每次用户登录，都检查一下当前登录的时间是否比这个分发时间晚，那就说明这次登录是已经有了这个token之后的行为。"}
{"qid": "301253397", "question": ["现在的前端框架全是通过API获得数据，如何记录用户登录状态？"], "question_desc": ["Angular，VUE，React等前端框架全是通过接口获得数据，我怎么记录用户登录状态？ 一般网站都是记录session来记录登录状态，现在的单页应…"], "author": "阿健大叔", "vote": 460, "answer": "正好之前想自己搞个项目写着玩的时候，遇到过这个问题。一开始，我也就是想用 session 来解决，但是后来想到为什么不用 jwt 呢？其实两种方式都能做到，但是用 session 的话，就会有分布式的问题，多台服务器怎么共享一个 session 池，常用的可能是 Redis，不是做后端的也就不献丑了，我主要来讲讲我当时思考出的使用 jwt 的大致流程。JWT 工作原理jwt 的本质其实是使用一点 cpu 的计算时间来代替储存空间，这点计算时间相对来说是比较廉价的。它是客户端向服务器请求一个 token，服务器验证了客户端是可信的之后，颁发一个唯一的 token 给客户端，之后客户端就可以使用这个 token 来与服务器通信，这就建立了两端之间的信任。所以你会发现，只要有这个 token，不管是谁都能向服务器发送请求，服务器都会认为是合法的。知道了 jwt 的工作原理之后，答主的问题就好解决了。将 Token 保存在 Runtime想要记录登录状态，就得先登录（废话...）。客户端将账户密码通过 HTTP 请求发送给服务器之后，服务器验证了通过了之后，生成一个 token 返回给前端，前端就可以从 HTTP 的 response 之中拿到这个 token。拿到 token 之后，我们就可以通过一个全局变量保存下来了，之后的请求都把这个 token 从全局变量中取出来，然后放到请求头之中发送给服务器就好了。将 Token 保存在 Localstorage但是随之而来你会发现，当我们重新刷新浏览器之后，本来已经登录了，但是服务器却还是让我们重新登录。这是因为我们把 token 存在了运行时，这说明 token 的生命周期只有应用的启动到销毁的运行状态下才会有，而刷新之后，就被清空了。解决这个问题的办法就是要让这个 token 持久化，解决方案之一就是存到 localstorage 中。登录请求成功之后，将 token 存到 localstorage 中，然年每次请求都从 localstorage 中将 token 取出来放到请求头中，这样就完成了 token 持久化，这也是很多应用采用的方式。但是这样就完美了吗？不尽然吧~如果我们的网站被攻击了 xss 注入攻击了（当然不希望发生），对方就能获取到 localstorage 中的全部内容了，这里就包括了 token 这个重要信息。这要怎么办呢？所以我觉得最好的方式是使用 cookie 来保存 token。使用 Cookie 保存 Token登录请求成功之后，http 不需要返回 token 的信息，而是服务器直接 setCookie，来将 token 直接写到客户端的 cookie 之中。你可能会说了，写到 cookie 中，xss 注入不是也可以读到吗？no、no、no，我们除了要设置 token 之外，还要再做一个更重要的事，就是设置 cookie 为 http-only，这样，我们就能确保 js 读取不到 cookie 的信息了，再加上 https，就能让我们的请求更安全一些了。使用 cookie 保存 token 有两个好处：安全性我们能够通过 https 和设置 cookie http-only 来保证 cookie 的信息足够安全，不易被窃取。客户端无感知客户端只知道登录成功了，随后的一切请求都无需任何处理，因为 cookie 是浏览器自带的，所以我们不需要关心如何处理 token。使用 localstorage 有一个问题，就是每当 token 过期，我们还需要重新起将新的 token 设置到 localstorage 中。而是使用 cookie 的话，客户端就无需做任何处理，服务器判断 token 过期之后，直接更新 cookie 就可以了。更新 Tokentoken 有一个特点，就是一旦生成，就不能再被改变，所以你会发现，假设你颁布了一个有效期15分钟的 token，过了15分钟之后，即使用户一直在活跃，也会被立即强迫推出。这个其实不太符合部分应用的需求。假如我们想要活跃的用户能一直保持登录状态的话，就需要快到15分钟的时候，去重新颁发一个 token 来延长登录有效期。而这时就会对同一个用户同时存在两个有效的 token，所以我们在重新颁发一个 token 的同时，还需要将快要过期的 token 拉黑，使其失效。下面是我当时做的项目链接，使用的就是这套登录流程，可供参考Hueco-Mundo/Bleach如何拉黑 token有些同学对如何拉黑和更新 token 比较感兴趣，我来简单说一下。在每一个请求进来的时候，需要做几件事是否需要验证 token（因为有一些 api 可能并不需要被验证）请求来的 token 是否合法（是否过期、是否被拉黑）解析 token，查看是不是快要过期，如果快要过期（比如距离过期时间差15分钟），重新颁发一个 token 并设置 cookie，并将当前 token 拉黑，请求继续。具体代码可以参考这里https://github.com/Hueco-Mundo/Bleach/blob/master/packages/server/src/app/middlewares/jwt.ts那么要如何拉黑 token 呢？这里是我的简要实现https://github.com/Hueco-Mundo/Bleach/blob/master/packages/server/src/app/utils/jwt-generator.ts#L48简单说就是使用数据库将要被拉黑的 token 存起来，然后每次在上面流程中验证 token 的时候，去查一下数据库看看 token 是不是被拉黑了。但是你会发现被拉黑的 token 会在数据库里越来越多，所以我们还可以开一个定时任务去将数据库里已经过期的 token 删掉，因为他们已经过期了，不存在被不被拉黑的问题。"}
{"qid": "301253397", "question": ["现在的前端框架全是通过API获得数据，如何记录用户登录状态？"], "question_desc": ["Angular，VUE，React等前端框架全是通过接口获得数据，我怎么记录用户登录状态？ 一般网站都是记录session来记录登录状态，现在的单页应…"], "author": "Joseph Lin", "vote": 37, "answer": "先说说 Session：以前实现动态网站的框架，从ASP/http://ASP.NET、JSP、PHP等等，一般都会提供Session类来保存用户会话期间的数据。Session的实现通常分为两部分：（1）通过Cookie（最常见，也有用请求参数等）将SessionID在浏览器端和后端进行传递；（2）后端通过SessionID去存储中检索数据。在前后端分离的情景下，前后端管理会话数据，本质上与以住的Session类的实现没有区别，即：（1）前端需要传递身份数据（如SessionID，UserID，AuthKey或JWT什么的）给后端；（2）后端通过此数据识别并检索会话数据。如果后端的API已经确定，那么如何传递和管理会话数据，已经由API规定了，只能按API的要求来做。下面稍微提一下常见的手段：如何向API发送会话数据如果前后端是采用HTTP(S)进行通讯，通常有以下几种方式进行前后端的会话数据传递：通过 HTTP  请求头的 Authorization 字段或自定义自段（推荐）Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l通过 HTTP 请求参数（如 QueryString 或 Body） /api/v2/orders?sid=YWxhZGRpbjpvcGVuc2VzYW1l仍然可以使用Cookie……如何保存会话数据至于前端代码如何记录会话数据，并在需要时通过API传递到后端，则方法更多：保存在本地存储中，如 Local Storage，Session Storage，WebSQL，IndexedDB等等保存在页面或内存中，如果采用单页应用，这是一个省事的方法，可以存在全局变量，或是采用Redux、Vuex等框架仍然可以保存在Cookie中……会话数据内容和格式为了节省通讯带宽，一般都尽量传递短小的内容，最常见的做法就是象传统一样传递一个SessionID，要求较高的可以自定义，或是采用JWT格式。一般情况下还需要对数据进行加密或是校验，避免安全问题。"}
{"qid": "301253397", "question": ["现在的前端框架全是通过API获得数据，如何记录用户登录状态？"], "question_desc": ["Angular，VUE，React等前端框架全是通过接口获得数据，我怎么记录用户登录状态？ 一般网站都是记录session来记录登录状态，现在的单页应…"], "author": "j小鑫", "vote": 34, "answer": "不请自来！其实你可以首先明确一下你的项目需求。我这里列举几个具体的情况来解释。第一种虽然项目采用了前后端分离的方式开发，你用React、Vue做了前端的单页项目。但是在上线的时候仍然会有后端同学帮你部署到一个后端的服务上去。这个时候后端是可以控制session的。也就是说，你可以将登陆成功的令牌保存在session里面，每次请求API都带上身份令牌，至于他怎么操作和过期时间之类的完全可以后端的同学来完成。你只需要判断后端返回给你的提示，是否过期，是否被登录等信息。第二种就是你的SPA在上线的时候没有任何的服务端部署，就是单纯的把你的项目丢到服务器的文件夹里面，保证用户能访问就好了。这个时候你可以用cookie保存身份令牌（当然了，每次请求API也是要带上的）。但是注意了，这个时候这个cookie，也就是身份令牌，需要你自己去维护。以为后端同学很少回去操作cookie的（就算可以他们也不会这么做）！在你每次请求API的时候，如果你的令牌过期了，那后端一般会统一返回一个固定的错误码给你，你就可以自己判断了。但是你在登陆成功之后设置cookie时，需要设置cookie的有效时间（如果不设置，关闭窗口就清楚了）！第三种WebApp！这个需要注意，当用户下载安装了你的WebApp之后。你的项目是在用户手机本地受到访问的，也就不存在网络服务器这一说。这时候你是没有办法使用cookie和session的（因为他们都是基于服务器的）。只能用localstorage来保存令牌。但是localstorage是没有过期时间的，只要设置了，他就一直存在，除非你把App卸载了。如果你的App需要过期时间，那就是能你自己去维护这个令牌了、或者也可以配合后端同学通过API的返回参数来判断。以上就是我在工作中遇到过的三种情况，希望对你有帮助！第一次写这么多，有错别字大家也别指出来，我会尴尬的（开玩笑的，大家多多指教就是）！"}
{"qid": "301253397", "question": ["现在的前端框架全是通过API获得数据，如何记录用户登录状态？"], "question_desc": ["Angular，VUE，React等前端框架全是通过接口获得数据，我怎么记录用户登录状态？ 一般网站都是记录session来记录登录状态，现在的单页应…"], "author": "丁长老", "vote": 18, "answer": "问题不复杂，基础技术没变，其他也没变。第一，http是无状态的。服务器端没法识别是哪个用户发出的请求第二，浏览器有cookie或者其他方法来保存一些本地数据，当然主要是cookie，浏览器会用一定的安全规则来确保不同的站点获取不同的cookie。服务器端告诉浏览器请保存一份cookies数据。一般这个时候会给一个session id给浏览器第三，浏览器会在用户刷新网页的时候顺便把对应的cookie文件一起发给服务器。（包含服务器提供的session id）第四，服务器拿到session id，服务器端的存储中获取相关的用户数据，然后就可以给用户自己的数据了。看上去就像登录的样子。不管前端如何变，这个基础操作没有变化的话，能做的无非是更改session id的生成方式，存储方式。其他的依然照旧。就这样。技术基础不能丢啊。"}
{"qid": "301253397", "question": ["现在的前端框架全是通过API获得数据，如何记录用户登录状态？"], "question_desc": ["Angular，VUE，React等前端框架全是通过接口获得数据，我怎么记录用户登录状态？ 一般网站都是记录session来记录登录状态，现在的单页应…"], "author": "坠落的阿良", "vote": 12, "answer": "jwt是招谁惹谁了，为什么这么多答案要黑一下，jwt只不过是一种token的生成标准而已啊，目前各个语言都有基于这个标准的实现库，比如java就有三个热门的库，至于有个答案说“那我是不是也可以搞一套xml方式的标准叫xwt”，当然可以啊，但标准之所以能成为标准，前提是规范易用，能够被大部分语言遵守并实现，所以要实现xwt的那位兄弟，我估计你可能要自己实现每个语言的xwt库 ，因为根本不会有别人想用xml来做web token了吧。还有很多人说jwt是在造session的轮子，这个也很好解释：首先这两个根本不是同一个东西，你甚至可以把jwt放在session里；其次当你的应用还不需要考虑分布式扩展、微服务模式等等扩展的时候，用session确实就能解决大部分的问题，但当你的应用达到需要各种扩展的时候，你势必要考虑把用户验证鉴权这一块独立出来，才好去做诸如单点登录，用户风控之类的体系，就像各个qq应用中的qq登录一样，一次登录所有产品都可用，这时候你说还能用session？1.即使session可以将存储设为redis等外部存储，但难道你觉得qq每新开发一个应用都得连上这个redis？2.如果你说都连redis没问题啊，那每个服务器对用户session的生成规则都不一样怎么办，是不是还得要一个标准？这个标准怎么定，大公司一般都内部制定，小公司没那个能力当然用已有标准最好了，jwt就是其中之一。讲讲jwt的正常使用流程：首先要明白在jwt的标准内可以对一个令牌制定很多诸如签发者、签发时间、过期时间等等信息，或者其它任何你想放进去的东西，而这些信息可以在对签名解密前就能获取到，也就是说在令牌失效中占大头的过期这种情况可以非常快判断出来。其次由于jwt的验证需要服务端保存的签名密钥，为了提高安全性最好每个用户都登录时生成一个密钥，并将其保存在缓存中，那么如何主动让一个jwt失效就很好实现了，把这个用户的密钥从缓存中删除就可以了。jwt的刷新，在用户正常的请求中判断一下jwt是否快过期，是则重新颁发一个jwt给客户端，通过cookie或响应头。最后关于jwt的大小，一般不会在jwt里放很多东西，比如放一个用户id就可以了，如果还觉得很长，那么可以将jwt压缩，压缩方式基本每个库都有默认实现或示例。非利益相关，只是觉得有些人的偏见太深，欢迎评论一起探讨。"}
{"qid": "301253397", "question": ["现在的前端框架全是通过API获得数据，如何记录用户登录状态？"], "question_desc": ["Angular，VUE，React等前端框架全是通过接口获得数据，我怎么记录用户登录状态？ 一般网站都是记录session来记录登录状态，现在的单页应…"], "author": "litbear lyn", "vote": 8, "answer": "老老实实的用现有的session-cookies才是最靠谱的。看了几个答案再扯JWT，搞来搞去就是再重新发明session-id，再把JWT弄成httpOnly的，请求头大了那么多徒增服务器负载。都2018年了还扯什么session-cookies移动端不友好"}
{"qid": "301253397", "question": ["现在的前端框架全是通过API获得数据，如何记录用户登录状态？"], "question_desc": ["Angular，VUE，React等前端框架全是通过接口获得数据，我怎么记录用户登录状态？ 一般网站都是记录session来记录登录状态，现在的单页应…"], "author": "洛飞", "vote": 11, "answer": "就问你一句，以前你的状态是怎么存的？以前怎么存，现在还可以怎么存。网页浏览，服务器一般是无状态的，而且请求接口跟访问页面，其实对服务器来说没有任何区别。什么Jwt, session啥的，毛线关系。问题不在点子上，回答的也是不多思考，张口就来。唉。。。"}
{"qid": "301253397", "question": ["现在的前端框架全是通过API获得数据，如何记录用户登录状态？"], "question_desc": ["Angular，VUE，React等前端框架全是通过接口获得数据，我怎么记录用户登录状态？ 一般网站都是记录session来记录登录状态，现在的单页应…"], "author": "鹅的艳后", "vote": 13, "answer": "emmmm，楼主可以看看《HTTP权威指南》。cookie里面一般存着服务器的session ID，session由服务器管理，服务器通过sessionID就可以知道是哪个用户。浏览器每次请求都会都会自动带上域名下的cookie。"}
{"qid": "301253397", "question": ["现在的前端框架全是通过API获得数据，如何记录用户登录状态？"], "question_desc": ["Angular，VUE，React等前端框架全是通过接口获得数据，我怎么记录用户登录状态？ 一般网站都是记录session来记录登录状态，现在的单页应…"], "author": "龙腾道默默地", "vote": 0, "answer": "首先，api也可以根据sessiin决定返回什么；其次，你所说的狭义的session，其实是某种浏览器与服务器框架自动实现的session，实际上广义地讲，手动在api里传递也是可以的。"}
{"qid": "301253397", "question": ["现在的前端框架全是通过API获得数据，如何记录用户登录状态？"], "question_desc": ["Angular，VUE，React等前端框架全是通过接口获得数据，我怎么记录用户登录状态？ 一般网站都是记录session来记录登录状态，现在的单页应…"], "author": "joker", "vote": 0, "answer": "api 请求可以发 cookie 的啊，直接用 session 不就可以了吗"}
{"qid": "301253397", "question": ["现在的前端框架全是通过API获得数据，如何记录用户登录状态？"], "question_desc": ["Angular，VUE，React等前端框架全是通过接口获得数据，我怎么记录用户登录状态？ 一般网站都是记录session来记录登录状态，现在的单页应…"], "author": "MRS·CHENG", "vote": 4, "answer": "答案就是token，用户第一次登录时，后台会根据某种定义好的规则返回一个token字符串前端拿到这token，存到sessionStorage里，在请求的接口上加上拦截器比如axios可以通过 拦截器设置config.headers.token = token这样就可以在请求接口的时候在请求头header里带上token，后端拿到这个token就可以进行校验了"}
{"qid": "301253397", "question": ["现在的前端框架全是通过API获得数据，如何记录用户登录状态？"], "question_desc": ["Angular，VUE，React等前端框架全是通过接口获得数据，我怎么记录用户登录状态？ 一般网站都是记录session来记录登录状态，现在的单页应…"], "author": "金洋", "vote": 2, "answer": "很奇怪为啥会提出这样的问题。用的都是http协议，没有任何本质区别。只是提交方式不一样。一个是整个网页一起刷新。一个是网页不自己刷新，需要你自己去更新。ajax也是基于http协议的。以前可以用session，现在一样可以用。session是用什么来识别用户的呢？用cookie。如果客户端不支持cookie，那么session也是没辙（无法记录用户状态）。所以前端完全可以用cookie或者session来记录用户登陆状态。当然用cookie的话，需要对用户信息进行加密处理。"}
{"qid": "301253397", "question": ["现在的前端框架全是通过API获得数据，如何记录用户登录状态？"], "question_desc": ["Angular，VUE，React等前端框架全是通过接口获得数据，我怎么记录用户登录状态？ 一般网站都是记录session来记录登录状态，现在的单页应…"], "author": "Stone", "vote": 1, "answer": "比较常用的流程:1，前端调用登录接口，接口返回 Token 数据。2，前端拿到 Token 之后，将 Token保存到 localstorage 或者 cookie 里面。3，当本地 localstorage 中的 token 存在并且没有过期的话，就认为用户是登录状态。4，请求需要提供 token 的接口时，从本地 localstorage 取出 token 放到 heahers (一般都是放在 headers)传递给后端，后端解析 token 拿到用户数据（也能知道token是否有效），根据程序逻辑返回对应数据。简单来说流程就是上面的，可以自行度娘一下 jwt 之类的参考一下。"}
{"qid": "301253397", "question": ["现在的前端框架全是通过API获得数据，如何记录用户登录状态？"], "question_desc": ["Angular，VUE，React等前端框架全是通过接口获得数据，我怎么记录用户登录状态？ 一般网站都是记录session来记录登录状态，现在的单页应…"], "author": "老蓝人", "vote": 2, "answer": "服务器：哟，老弟，来啦，办张卡呗客户端：办卡能干啥服务器：你个损色，有卡你不想干啥就干啥客户端：那…开张卡？服务器：好咧，老弟，填下账号密码哟客户端：xxxxxx xxxxxx服务器：卡你收好，别弄丢咯客户端：咋用咩服务器：小笨蛋，下次想要啥服务，直接出示卡就行了一个月后…客户端：大姐，我想… ，我有卡服务器：哟，老弟，你这卡过期了，喏，去那边填下账号密码给你补张卡客户端：xxxxx xxxxx服务器：好咧，老弟，看你憋那样，快去嗨吧"}
{"qid": "52368821", "question": ["知识图谱怎样入门？"], "question_desc": ["或者说怎样具体整一个能跑的中文的知识图谱Demo或Example出来，英文的告诉下怎么自己跑也行，， 即 Knowledge Graph From S…"], "author": "zibuyu9", "vote": 204, "answer": "到CNKI搜索一些比较不错期刊的中文综述，应该是最快的入门办法："}
{"qid": "52368821", "question": ["知识图谱怎样入门？"], "question_desc": ["或者说怎样具体整一个能跑的中文的知识图谱Demo或Example出来，英文的告诉下怎么自己跑也行，， 即 Knowledge Graph From S…"], "author": "徐超", "vote": 146, "answer": "分享一下学习总结：一、 知识图谱技术体系知识图谱的构建主要涉及到知识建模、知识抽取、知识融合、知识存储、知识计算以及知识应用，具体可以归纳如下：二、 知识图谱实施方法使用现有的套装工具（如LOD2、Stardog）在现有套装工具的基础上进行扩充针对知识图谱生命周期的各种工具进行组合有针对性的开发某种工具从零开始构建三、 技术架构知识图谱架构如下图，这其中主要包括如下几个部分：3.1 数据采集主要涉及到爬虫技术3.2 建立本体可以采用如下两种方式自顶向下：由专家创建自底向上：从现有的行业标准转化；从现有高质量数据源（如百科）转化3.3 本体编辑有很多现有的工具：如Protégé、Semantic Turkey、Swoop、OBO-Edit等，存在的缺点是需要个人编辑，不能多人并行编辑3.4 知识抽取针对不同的目标数据类型，可以提供文件导入、ETL、Wrapper、Extractor三种方式：结构化数据， 如RDB中的数据，直接ETL或文件上传半结构化数据， 如百科，配置Wrapper解析逻辑文档、文本类数据， 如一般的web数据，利用文本抽取引擎的自然语言处理技术（NLP）、机器学习，利用Extractor抽取成结构化的知识数据3.5 知识融合把结构化数据、半结构化数据、非结构化数据的知识表达形式都统一成RDF的形式，便于存储和查询。具体的知识融合主要包括如下两种类型：合并外部知识库： 数据层的融合、模式层的融合开放数据集成框架：LDIF合并关系型数据库：将关系型数据转换成RDF的格式，现有工具Triplify、 d2rServer 、OpenLink、 Virtuoso 、SparqlMap等3.6 知识存储知识存储的主流存储方式是图数据库，但具体实施时需要根据具体的业务需求来选择存储方式，下表总结了各种存储方式的特点：关系型数据库存储三元组表（S，P，O）: 类似RDF存储结构，以元组为单元进行存储。语义较为明确问题：大量自连接操作的开销巨大关系型数据库存储属性表: 属性相似的主语聚为一张表，类似关系型数据结构，每一条数据代表一个实体，每一列代表一个属性问题：（1）、 RDF灵活性（高于一阶的关系查询很复杂）（2）、 查询时必须指定属性，无法做不确定属性的查询关系型数据库存储垂直分割: 以谓语划分三元组表，根据属性的不同建立数据表，数据结构较为清晰问题：（1）、大量数据表（2）、删除属性代价大关系型数据库存储RDF存储: 专为存储三元组形式的数据而设计的专用数据库，通过六重索引（SPO、SOP、PSO、POS、OSP、OPS）的方式解决了三元组搜索的效率问题优点：（1）、三元组模式查询（triple pattern）的高效执行（2）、任意两个三元组模式的高效归并连接（merge-join）缺点：（1）、六重索引意味着6倍空间开销（2）、更新维护代价大图数据库存储: 图数据库的结构定义相比RDF数据库更为通用，实现了图结构中的节点，边以及属性来进行图数据的存储，典型的开源图数据库就是Neo4j。优点：数据库本身提供完善的图查询语言、支持各种图挖掘算法，缺点：图数据库的分布式存储实现代价高，数据更新速度慢，大节点的处理开销很高。时态数据存储: 知识图谱中的时态信息包含以下四个方面：事实的生成时间某事实的有效时间段某一对象在特定历史时刻的状态知识图谱在过去特定时间的版本存储原则关系型数据：使用图形数据存储关联型数据：作为记录型数据存入合适的存储中，通过实体链接与图谱中实体关联。属性型数据：作为实体的数值属性存入知识图谱时态型数据：使用基础存储上的时态处理中间件进行存储与查询3.7 知识表现知识表现主要涉及语义网的知识，其中与知识图谱相关紧密的是RDF、 OWL、SPARQL几种，具体的特征和用处如下表：3.8 知识推理jena是一个java 的API，用来支持语义网的有关应用，学习jena需要了解XML 、RDF、 Ontology、OWL等方面的知识。RDFox是一个高度可扩展的内存RDF三重存储，支持共享内存并行数据推理。它是一个用C ++编写的跨平台软件，带有一个Java包装器，可以与任何基于Java的解决方案轻松集成3.9 知识检索索引系统的构建，并对查询的结果进行排序3.10 人机交互集成现有的可视化工具，实现知识图谱的可视化。常见的可视化工具如3D.js、Echarts等。欢迎关注专栏：数联未来"}
{"qid": "52368821", "question": ["知识图谱怎样入门？"], "question_desc": ["或者说怎样具体整一个能跑的中文的知识图谱Demo或Example出来，英文的告诉下怎么自己跑也行，， 即 Knowledge Graph From S…"], "author": "鲍捷", "vote": 788, "answer": "（好像说的不只是入门了。算是个成长打怪小提纲吧）\n任何一个学科，重要的不是静态的知识本身，而是建立知其然（Framework），知其所以然（Rationale），最后到知未然（Insights）。最重要的便是产生insights，因拥有洞察而知关键所在，所以能预测未来的走向，不人云亦云。\n知识图谱作为一门学问，绝不是用个图数据库写几条查询，或者用规则写一个表格的提取，就可以称为成功的运用的。和所有的学科一样，都需要长期的艰苦的努力，在充分了解前人成果的基础上，才有可能做出一点点成绩。\n知识图谱作为人工智能（AI）的一个分支，和AI的其他分支一样，它的成功运用，都是需要知道它的所长，更需要知道它的所短的。特别是AI各个学派林立，经验主义（机器学习）、连接主义（神经网络）、理性主义（知识工程）、行为主义（机器人）各个方法的优劣，倘若不能有纵览的理解，也难以做正确的技术选型，往往盲目相信或者排斥一种技术。AI是一个极端需要广阔视野的学科。\n知识图谱涉及知识提取、表达、存储、检索一系列技术，即使想有小成，也需要几年的功夫探索。如下所列，应该是每个知识图谱从业者都应该了解的一些基本功：\n知道Web的发展史，了解为什么互联和开放是知识结构形成最关键的一件事。（我把这个列第一条，是我的偏见——但我认为这是最重要的一个insights）\n知道RDF，OWL，SPARQL这些W3C技术堆栈，知道它们的长处和局限。会使用RDF数据库和推理机。\n了解一点描述逻辑基础，知道描述逻辑和一阶逻辑的关系。知道模型论，不然完全没法理解RDF和OWL。\n了解图灵机和基本的算法复杂性。知道什么是决策问题、可判定性、完备性和一致性、P、NP、NExpTime。\n最好再知道一点逻辑程序（Logic Programming），涉猎一点答集程序（Answer Set Programming），知道LP和ASP的一些小工具。这些东西是规则引擎的核心。如果不满足于正则表达式和if-then-else，最好学一点这些。\n哦，当然要精通正则表达式。熟悉regex的各种工具。\n从正则文法到自动机。不理解自动机很多高效的模式提取算法都理解不了。\n熟悉常见的知识库，不必事事重新造轮子，如Freebase, Wikidata, Yago, DBPedia。\n熟悉结构化数据建模的基本方法，如ER，面向对象，UML，脑图。\n学会使用一些本体编辑器，如Protege。（Palantir就是个价值120亿美元的本体编辑器）\n熟悉任何一种关系数据库。会使用存储过程写递归查询。明白什么叫物化视图、传递闭包、推理闭包。\n熟悉任何一种图数据库。明白图的局部索引和关系的全局索引的理论和实践性能差异。\n熟悉词法分析的基本工具，如分词、词性标注\n熟悉句法分析的基本工具，如成分分析、依存文法分析、深层文法分析\n熟悉TFIDF、主题模型和分布式表示的基本概念和工具。知道怎么计算两个词的相似度、词和句子的关联度。\n知道怎么做命名实体识别。知道一些常用的词表。知道怎么用规则做关系提取。\n为了上述的深化，要掌握一些机器学习的基本概念，识别、分类、聚类、预测、回归。掌握一些机器学习工具包的使用。\n谨慎地使用一些深度学习方法，最好在是了解了神经网络的局限之后，先玩玩BP。主要是用用LSTM。\n了解前人已经建好的各种Lexical数据库，如Wordnet, framenet,  BabelNet, PropBank。熟悉一些常用的Corpus。\n知道信息检索的基本原理。知道各种结构的索引的代价。\n掌握Lucene或者Solr/Elasticsearch的使用。\n学会混合使用多种数据库，把结构化数据和非结构化数据放在一起使用。体会数据建模和查询的成本。\n学会一些概念原型工具，如Axure和Semantic Mediawiki。快速做MVP。\n以上是挂一漏万的一些罗列。知识图谱是交叉性的、实践性的学问，当然不必先蒙头学几年才能来做事。How to get to Carnegie Hall? Practice, Practice, Practice.\n所以Just practice。最后推销一下我在中国中文信息学会《前沿技术讲习班》第三期做的讲座：精益知识图谱方法论 - 文因互联"}
{"qid": "52368821", "question": ["知识图谱怎样入门？"], "question_desc": ["或者说怎样具体整一个能跑的中文的知识图谱Demo或Example出来，英文的告诉下怎么自己跑也行，， 即 Knowledge Graph From S…"], "author": "云将", "vote": 62, "answer": "Neo4j知识图谱构建1.运行环境：python3.6.5windows10具体包依赖可以参考文件requirements.txtpip install -r requirements.txt2.Pandas抽取excel数据Excel数据结构如下通过函数data_extraction和函数relation_extrantion分别抽取构建知识图谱所需要的节点数据以及联系数据，构建三元组。数据提取主要采用pandas将excel数据转换成dataframe类型invoice_neo4j.py3.建立知识图谱所需节点和边数据DataToNeo4jClass.pyEnjoy it!详细内容请到github上下载  https://github.com/Skyellbin/neo4j-python-pandas-py2neo-v3参考书籍："}
{"qid": "52368821", "question": ["知识图谱怎样入门？"], "question_desc": ["或者说怎样具体整一个能跑的中文的知识图谱Demo或Example出来，英文的告诉下怎么自己跑也行，， 即 Knowledge Graph From S…"], "author": "lemonhu", "vote": 27, "answer": "关于金融证券知识图谱构建的一个简单示例，适合入门：lemonhu/stock-knowledge-graph面向开放域的知识抽取可参考：lemonhu/open-entity-relation-extraction"}
{"qid": "52368821", "question": ["知识图谱怎样入门？"], "question_desc": ["或者说怎样具体整一个能跑的中文的知识图谱Demo或Example出来，英文的告诉下怎么自己跑也行，， 即 Knowledge Graph From S…"], "author": "漆桂林", "vote": 50, "answer": "可以读一下http://zhishi.me的论文，复现一下就可以了。另外，我们实验室正在做佛学知识图谱和司法知识图谱，感兴趣的朋友可以加入，我会根据能力来安排不同的任务。"}
{"qid": "52368821", "question": ["知识图谱怎样入门？"], "question_desc": ["或者说怎样具体整一个能跑的中文的知识图谱Demo或Example出来，英文的告诉下怎么自己跑也行，， 即 Knowledge Graph From S…"], "author": "灰灰", "vote": 47, "answer": "可能有一些小伙伴都不知道什么是知识图谱，或是对知识图谱的概念比较模糊吧。其实这个概念相对比较新，国内很少有相关博文，能把知识图谱解释的通俗易懂。之前我也对知识图谱到底是什么，能做什么也是一脸懵逼，后来也是看了一些国内外的论文，并把它写成了系列文章，才对知识图谱有了更多的认识。一. 什么是知识图谱知识图谱属于人工智能的重要分支——知识工程的研究范畴，是利用知识工程理论建立大规模知识资源的一个杀手级应用。知识图谱给互联网语义搜索带来新的活力，在智能问答中也大显神威，已经成为知识驱动的智能应用的基础设施。知识图谱与大数据和深度学习一起，已经成为推动互联网和人工智能发展的核心驱动力之一。1. 定义知识图谱在学术界还没有统一的定义，根据维基百科，知识图谱2012年首先由谷歌公司提出，是一个提供智能搜索服务的大型知识库。因此，这里我们可以将知识图谱理解为，对语义知识的一种形式化描述框架。图一 谷歌知识图谱2. 意义知识图谱从语义角度出发，通过描述客观世界中概念、实体及其关系，从而让计算机具备更好地组织、管理和理解互联网上海量信息的能力。更具体的说，在人类与互联网世界交互的过程中，产生了繁杂庞大的信息，这些信息一般被图片声音文字视频这些数据载体保存。我们希望计算机可以分析阅读理解这些数据，精准挖掘找到数据背后隐藏的有价值的知识，在用户需要的时候提供知识服务。3. 研究问题知识图谱研究的主要问题有 如何在计算机中表示知识，将知识保存到合适的数据载体中（知识数据化），以及如何将大规模的互联网数据转化为我们定义好的知识数据的形式（数据知识化）等等。知识图谱技术具体指知识图谱构建和应用的技术，涵盖内容包罗万象，是融合了知识表示与推理、信息检索与抽取、自然语言处理、语义网、认知计算、数据挖掘与机器学习等方向的交叉研究。二. 知识图谱的发展历史今天我们先从知识图谱历史发展的角度来初步了解知识图谱，揭开知识图谱的神秘面纱。知识图谱是人工智能重要分支知识工程在大数据环境中的成功应用。1. 前知识工程时期（1956-1970）知识图谱的发展伴随着人工智能技术的发展而发展。1956年，马文・明斯基、约翰·麦卡锡、克劳德·香农、艾伦·纽厄尔等科学家在美国的一个小镇汉诺斯举办了一个会议，探讨着一个不食人间烟火的话题：如何用机器模拟智能，并为会议讨论的内容起了一个名字：人工智能。这是“人工智能”这一术语的首次提出，标志“人工智能”这门学科正式诞生，1956年也就成为了人工智能元年。之后几年，人工智能得到蓬勃发展。简单介绍一下人工智能的两大学派：连接主义和符号主义。图二 &amp;amp;quot;智能&amp;amp;quot;包含意识、思维、认知、本能等许多方面连接主义学派受到神经科学的启发，认为&#34;智能&#34;是无数&#34;非智能&#34;的神经细胞互相作用的结果，人与机器之间其实没有本质的差别。如果我们能模拟神经细胞的行为，进而构造组织一张人工的&#34;神经网络&#34;，那么理论上就能模拟出人的大脑，创造所谓的&#34;智能&#34;。符号主义认为认为人的智能可以用数理逻辑表达。数理逻辑在20世纪30年代开始被用于描述智能行为，模拟人类智能活动。计算机出现后，该理论又被应用到计算机上，实现了逻辑演绎系统，从而又发展出后来的专家系统和知识工程理论等。这一阶段具有代表性的工作是通用问题求解程序GPS（The General Problem Solver）。GPS旨在实现一个宏大的目标：给定问题的描述，可以解决任何问题的计算机程序。他是第一个将问题的解决策略从特定问题的知识中分离出来的程序，并且激励了很多在问题解决领域的研究。这一时期的知识表示方法主要有逻辑知识表示、产生式规则、语义网络等。这个时期学者研究的重点在于，如何设计出一个推理模型来求解通用问题，但是却忽视了知识在问题解决中扮演的重要角色。2. 专家系统时期、（1970-1990）早期学者注重通用问题的求解，试图模仿人的求解问题的逻辑思维能力构造智能系统，而忽略了知识（人的认知）对智能的支持。什么是认知？什么是知识？维基百科有云，认知或认识（cognition）在心理学中是指通过形成概念、知觉、判断或想象等心理活动来获取知识的过程，或者说信息加工的心理过程。知识即是经过加工的信息。1970年开始，科学家们提出各种知识表示技术，将领域专门知识表示成计算机可以识别的数据形式。人工智能开始转向建立基于知识的系统，通过 知识库+推理机 实现智能的专家系统。当时比较知名的专家系统有MYCIN 医疗诊断专家系统、识别分子结构的DENRAL 专家系统以及计算机故障诊断 XCON 专家系统等。1977年，在第五届国际人工智能会议上，美国斯坦福大学计算机科学家费根鲍姆教授(E．A．Feigenbaum) 系统地阐述了“专家系统”的思想，并提出了“知识工程”的概念，正式确立知识在人工智能中的重要地位。这一时期的知识表示方法主要有框架表示法、脚本表示语言等。同时期出现了许多用这些知识表示方法构建的知识库，如Cyc 常识知识库，它们都是通过人工添加知识构建而成。图三 知识工程发展历史3. 万维网时期 （1990-现在）如何高效的让计算机获得知识？万维网之父，Tim Berners-Lee 最初设计互联网的初衷就是希望通过网络把全世界的知识互联在一起，使得知识从封闭知识走向开放知识，从集中知识成为分布知识。他认为首先应该构造一个文档互联的网络，然后在这个基础上再构建一个具备可以被计算机识别的知识结构的知识互联的网络。第1个目标已经实现了，就是现在我们每天都接触的有互联网，那知识互联的网络是什么意思？在web2.0中，互联网上的数据绝大部分以html的形式存在，这样的形式确实适合人机界面之间的信息传递，方便人类的阅读和理解，但是网页内容没有采用形式化的表示方式，缺乏明确的语义信息，Web内容对于计算机而言只是普通的二进制数据，对其符号背后隐藏的知识无法被计算机识别。所以，面对当今信息时代的海量信息，当人们希望借助计算机来获取自己需要的信息时，这种html网页表示形式的瓶颈就凸显出来了，这也正是基于关键字匹配的传统搜索引擎的壁垒所在。于是，针对第二个目标，1998 年Tim Berners-Lee 首次提出语义网概念，也就是后来人们常常说到的web3.0。这是一个极具野心的宏大概念，目标是对现有web内容增加语义支持，使得计算机可以自动识别和理解互联网上的信息，完成智能化应用任务。针对语义网概念，一整套标准化的相关技术不断被提出以及完善，形成了语义网技术堆栈，主要包含了RDF（资源描述框架） 和 OWL（万维网本体描述语言）等内容，这里面包含了过去几十年逻辑推理和知识表示等知识工程理论方面的研究成果。要实现这个目标是一个相当艰巨的任务————必须把互联网上海量庞大的内容信息转化为机器可以理解和计算的知识形式。早期专家系统中手工编辑知识库的方式面对这个任务显然捉襟见肘，没有用武之地。幸好，大规模维基百科类富结构知识资源的出现，加上许多从万维网上自动提取大规模知识的方法的提出，使得知识获取工作取得重大成果，相关代表性工作有比如 DBpedia， Freebase YAGO， DeepDive， NELL， Probase 等等。图四 开放链接数据项目正是在这样的大背景下，谷歌在收购Freebase后，于2012 年推出了基于语义网技术的一款威力强大的应用————知识图谱。本文还有下半部分，也许没有直接回答作者的问题，但相对比较通俗易懂的带大家从零开始入门知识图谱，希望能够对大家有帮助。灰灰：知识图谱概论（二）：概念具象化描述"}
{"qid": "52368821", "question": ["知识图谱怎样入门？"], "question_desc": ["或者说怎样具体整一个能跑的中文的知识图谱Demo或Example出来，英文的告诉下怎么自己跑也行，， 即 Knowledge Graph From S…"], "author": "二又", "vote": 34, "answer": "刘知远老师所提供的两篇论文，对知识图谱问题进行了详细介绍，非常适合入门。在此我再提供一些个人觉得非常优秀实用的论文供参考。庄严,李国良,冯建华. 知识库实体对齐技术综述[J]. 计算机研究与发展,2016,(01):165-192.Wang Yuanzhuo, Jia Yantao,  Liu Dawei,  Jin Xiaolong,  Cheng XueqiOpen. Web Knowledge Aided Information Search and Data Mining [J].  Jisuanji Yanjiu yu Fazhan/Computer Research and Development, vol. 52, issue 2 (2015)Bernstein P A,  Madhavan  J, Rahm E.   Generic schema matching, ten years later  [J].Proceedings of the VLDB Endowment, vol. 4, issue 11 (2011) pp. 695-701Shvaiko  P , Euzenat  J. Ontology matching: State of the art and future challenges [J].   IEEE Transactions on Knowledge and Data Engineering ( Volume: 25, Issue: 1, Jan. 2013 ) Otero-Cerdeira  L , Francisco  J, Rodríguez-Martínez  A.  Ontology matching:  A literature review [J].  Expert Systems with Applications, vol. 42 (2015) pp. 949--971以上五篇论文大多对实体对齐和本体匹配做了很多综述，希望能对你知识图谱的进一步研究有参考价值"}
{"qid": "52368821", "question": ["知识图谱怎样入门？"], "question_desc": ["或者说怎样具体整一个能跑的中文的知识图谱Demo或Example出来，英文的告诉下怎么自己跑也行，， 即 Knowledge Graph From S…"], "author": "勇灬敢的心", "vote": 13, "answer": "知识图谱的应用从最初的Google搜索，已经蔓延到了聊天机器人，大数据风控、投资、智能医疗、自适应教育、推荐系统、物联网等多个重要领域，并逐步成为不可缺少的一门人工智能技术。但由于系统性资料的缺乏，导致让很多人在学习和实践的路上重复造轮子并且走了不少弯路。首先，你需要对知识图谱技术、行业应用全貌有很清晰的认识。其次，要有一个完整知识图谱项目全生命周期所涉及到的步骤以及对每个关键问题的解决思路。一、什么是知识图谱？知识图谱是由Google公司在2012年提出来的一个概念。从学术的角度，知识图谱是语义网络（Semantic Network）的知识库。但这有点抽象，所以换个角度，从实际应用的角度出发其实可以简单地把知识图谱理解成多关系图（Multi-relational Graph）。 那什么叫多关系图呢？ 学过数据结构的都应该知道什么是图（Graph）。图是由节点（Vertex）和边（Edge）来构成，但这些图通常只包含一种类型的节点和边。但相反，多关系图一般包含多种类型的节点和多种类型的边。比如左下图表示一个经典的图结构，右边的图则表示多关系图，因为图里包含了多种类型的节点和边。这些类型由不同的颜色来标记。﻿在知识图谱里，通常用“实体”来表达图里的节点、用“关系”来表达图里的“边”。实体指的是现实世界中的事物比如人、地名、概念、药物、公司等，关系则用来表达不同实体之间的某种联系，比如人-“居住在”-北京、张三和李四是“朋友”、逻辑回归是深度学习的“先导知识”等等。现实世界中的很多场景非常适合用知识图谱来表达。 比如一个社交网络图谱里，我们既可以有“人”的实体，也可以包含“公司”实体。人和人之间的关系可以是“朋友”，也可以是“同事”关系。人和公司之间的关系可以是“现任职”或者“曾任职”的关系。 类似的，一个风控知识图谱可以包含“电话”、“公司”的实体，电话和电话之间的关系可以是“通话”关系，而且每个公司它也会有固定的电话。 基于知识图谱的这种对于关系的推理特性，知识图谱被很多人工智能领域科学家视为AI的大脑，被认为是未来强人工智能诞生的必要条件。二、知识图谱的应用目前，Facebook、亚马逊、bat等大型科技公司都根据平台的数据构建了知识图谱，但相比于机器学习、深度学习等技术，知识图谱的应用在国内仍处于初始阶段，知识图谱的赛道还远谈不上拥挤，存在着大量机会！在金融领域知识图谱是一个重要的反欺诈手段。如，基于大数据整合不同来源的客户数据构建出知识图谱，就可以有效识别出团体欺诈、身份造假等欺诈行为。此外，知识图谱还可应用于智能搜索和精准营销等领域。智能搜索的功能类似于知识图谱在谷歌，百度上的应用。也就是说，对于每个搜索的关键词，我们可以通过知识图谱来返回更丰富，更全面的信息。比如搜索一个人的身份证号，智能搜索引擎可以返回与这个人相关的所有历史借款记录、联系人信息、行为特征和每一个实体的标签，知识图谱在营销领域的应用，可以结合多种数据源去分析实体之间的关系，从而对用户的行为有更好的理解。比如一个公司的市场经理用知识图谱来分析用户之间的关系，去发现一个组织的共同喜好，从而可以有针对性的对某一类人群制定营销策略。其实，知识图谱在金融、医疗、电商、推荐系统和物联网等行业已得到了广泛的探索。相信随着研究的深入，会有越来越多的应用场景被发掘出来。"}
{"qid": "52368821", "question": ["知识图谱怎样入门？"], "question_desc": ["或者说怎样具体整一个能跑的中文的知识图谱Demo或Example出来，英文的告诉下怎么自己跑也行，， 即 Knowledge Graph From S…"], "author": "王乐", "vote": 9, "answer": "正在写一个知识图谱系列的文章，打算从理论到实践一步一步的写一写如何搭建自己的知识图谱，目前更新到关系抽取部分了，想自己搭建的知识图谱的可以关注一下。下面是系列文章链接：大话知识图谱--知识图谱的定义和应用场景 大话知识图谱--构建知识图谱第一步定义数据模型大话知识图谱--知识抽取之命名实体识别大话知识图谱 -- 知识抽取之关系抽取"}
{"qid": "52368821", "question": ["知识图谱怎样入门？"], "question_desc": ["或者说怎样具体整一个能跑的中文的知识图谱Demo或Example出来，英文的告诉下怎么自己跑也行，， 即 Knowledge Graph From S…"], "author": "李晓喆", "vote": 21, "answer": "1、确定领域：电影？图书？。。。。。2、确定知识图谱用什么框架和知识表示理论。2、上手工具，比如 protégé3、只做demo的话，不用费劲，自己编辑几条数据就够了。4、Just do it~无耻一下，列几个参考：李晓喆：知识图谱构建过程中用到的工具？ 李晓喆：怎样从零开始做一个 Google Knowledge Graph 或者 Freebase 一样的的知识库系统，有哪些困难？李晓喆：准研究生请教，语义网如何入门？李晓喆：如何在protege软件上开发一个关于红楼梦家族的知识库系统，并支持其中的一些查询？目前的提供开放API的中文知识图谱有哪些？李晓喆：如何搭建一个类似百度百科这样的面向大众的知识库平台呢？李晓喆：Freebase 关闭之后，最好的替代品是什么？"}
{"qid": "52368821", "question": ["知识图谱怎样入门？"], "question_desc": ["或者说怎样具体整一个能跑的中文的知识图谱Demo或Example出来，英文的告诉下怎么自己跑也行，， 即 Knowledge Graph From S…"], "author": "徐波", "vote": 4, "answer": "一般来说，知识图谱入门都是从构建一个百科知识图谱开始。因为百科数据源具有知识全面、实体独立、格式统一和质量优良等特点，决定了百科图谱具有知识完备、获取容易、抽取简单且质量优良的优点。比较适合入门的百科知识图谱包括电影知识图谱、音乐知识图谱、药品知识图谱等。网上有很多相关的知识，github上也有很多相关的代码了。基本流程有下面一些：•基于单源的百科图谱构建：从单个数据源构建百科图谱    •数据获取：先得到所有实体的页面    •属性抽取：从每个实体页面中抽取出属性-值对    •关系构建：从属性-值对中建立实体与实体的关系    •概念层级体系构建：建立概念与概念之间的层次关系    •实体分类：建立实体与概念之间的实例关系•基于多源的百科图谱融合：从多个数据源构建百科图谱    •基于多个知识图谱的融合        •概念融合：融合不同知识图谱的概念层级体系        •实体对齐：将不同知识图谱中的实体对齐        •属性对齐：将不同知识图谱中的属性对齐        •属性值融合：将相同实体相同属性的属性值融合    •基于多源异构数据的融合：参考google的Knowledge Vault更多资料可以参考我在ccks2017的讲习班上介绍过的百科知识图谱构建以及《知识图谱：概念与技术》中的第六章【百科图谱构建】。CCKS 2017-全国知识图谱与语义计算大会知识图谱：概念与技术 (豆瓣)"}
{"qid": "52368821", "question": ["知识图谱怎样入门？"], "question_desc": ["或者说怎样具体整一个能跑的中文的知识图谱Demo或Example出来，英文的告诉下怎么自己跑也行，， 即 Knowledge Graph From S…"], "author": "集智科学家", "vote": 17, "answer": "要想认识知识图谱，先要认识知识。一图胜千言：这是Quora上一张经典的关于信息与知识的区别的示意图（在更零碎的情况下，左图也可以表示为”数据“）信息是零散的，而知识则是在各种层面上相互联系的信息。原始出处：https://www.siilo.com/blog/information-vs-knowledge知识图谱的概念最初由谷歌于2012年提出，目的是利用网络多源数据构建的知识库来增强语义搜索、提升搜索质量。谷歌知识图谱负责人 Amit Singhal 在介绍知识图谱时提到“The world is not made of strings，but is made of things”。知识图谱旨在以结构化的形式描述客观世界中概念、实体间的复杂关系，将互联网的信息表达成更接近人类认知世界的形式，为人类提供了一种更好地组织、管理和理解互联网海量信息的能力。简单讲，知识图谱是让信息之间创建联系，让人类更容易获得知识的一个技术。想要简单粗暴手把手的知识图谱入门，集智学园最近在进行知识图谱课程的推广，是一个非常系统的入门，从基础知识到上手操作都覆盖了。作为复杂世界的探索者，即便只是停留在了解知识图谱的知识这一层面上，也使我对于信息，知识以至于学习过程的理解有了长足的进步，我也希望在这里把这样的资源分享给知友们。知识图谱课程简单的大纲"}
{"qid": "52368821", "question": ["知识图谱怎样入门？"], "question_desc": ["或者说怎样具体整一个能跑的中文的知识图谱Demo或Example出来，英文的告诉下怎么自己跑也行，， 即 Knowledge Graph From S…"], "author": "TechOnly", "vote": 11, "answer": "Quora上的答案还是挺详细的，还可以顺便看看链接页面里列的周边近似的问题https://www.quora.com/How-do-you-build-and-maintain-a-knowledge-graph"}
{"qid": "52368821", "question": ["知识图谱怎样入门？"], "question_desc": ["或者说怎样具体整一个能跑的中文的知识图谱Demo或Example出来，英文的告诉下怎么自己跑也行，， 即 Knowledge Graph From S…"], "author": "Lu Yaojie", "vote": 19, "answer": "推荐发布于 CCKS 2017 的讲习班幻灯片，主要包含：知识图谱导论、知识图谱构建、知识获取方法及知识图谱实践。此外，还推荐发布于 CCKS 2018 的 知识图谱发展报告(2018) 。同时推荐今年的 CCKS 会议：2020全国知识图谱与语义计算大会 - China Conference on Knowledge Graph and Semantic Computing - 南昌，2020年11月。全国知识图谱与语义计算大会（CCKS: China Conference on Knowledge Graph and Semantic Computing）是中国中文信息学会语言与知识计算专委会定期举办的全国年度学术会议。======================2019全国知识图谱与语义计算大会 - China Conference on Knowledge Graph and Semantic Computing - 杭州，2019年8月24日-8月27日。2018全国知识图谱与语义计算大会 - China Conference on Knowledge Graph and Semantic Computing - 天津，2018年8月14日-8月17日。2017全国知识图谱与语义计算大会 - China Conference on Knowledge Graph and Semantic Computing - 成都，2017年8月26日-8月29日。2016全国知识图谱与语义计算大会 - China Conference on Knowledge Graph and Semantic Computing - 北京，2016年9月19日-9月22日。"}
{"qid": "52368821", "question": ["知识图谱怎样入门？"], "question_desc": ["或者说怎样具体整一个能跑的中文的知识图谱Demo或Example出来，英文的告诉下怎么自己跑也行，， 即 Knowledge Graph From S…"], "author": "DatasPM", "vote": 2, "answer": "知识图谱入门精品课程，跟着有经验的大牛学习吧http://suo.im/6cPRtl"}
